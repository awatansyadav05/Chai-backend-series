 The model we are using in this project ---eraser.io
- [Model link] (https://app.eraser.io/workspace/YtPqZ1VogxGy1jzIDkzj)


POSTMAN--> Postman is a popular API testing and development tool that allows developers to design, test, and document APIs. It provides a user-friendly interface for making HTTP requests and receiving responses, which is especially useful for backend and frontend developers when working with RESTful APIs. 

[
  when the user register code written move to the postman for API testing 
  1.) create Collections
  for the register, login and logout
  2.) NOTE--> one for saving the time like for typing the body req on must save time for creating the {{server}} in the Environment
  {{server}}== http://localhost:8000/api/v1
]

Lecture 16: Get to know about the access token and refresh token {already written in contoller.js}  


lecture 17: [
  majority controllers how can we write ----> more controllers
  ~learned to created models and created the subscription model from which the user is subscribing to the channel
  
  ~PRODUCTION_LEVEL_TIP ::  ensure you have created contoller file another for different tings like if the user wants to upload the profilephto then he must only upload profilephto else he have to fetch the user page full. 
]

Lect-18: { SUBSCRIPTION MODEL
  we have to count the number of subscriber per channel, so we will create the documents and as per the model the document--counting document means the counting of channel 

  so according to video
  we have the subscriber and channel 
  user -> a,b,c,d,e
  channel -> CAC, HCC, FCC 
  so we will have to count the number of subscriber subscribing the channel so we will count the number of documents we created. 

  But we have to count the  number of channel subscribing by user 'c' so what we will we do????
  so we will just count the [subscribers se channel ke list niakl ke laao]

}

lecture-19: {AGGREGRATION AND PIPELINES}
AGGREGRATION--> pipelines are the different stages that process our documents.
--> An aggregration pipelines can return results for groups of documents, for e.g. return the total ,average, maximum and minimum values


syntax--> db.users.aggregate([
  {

  },
  {

  }
])

$lookup: is used to combine data from two different Collections, like joining two tables in SQL.  
from: the other collection you want to get data from ...
localfield: the field in the current collection that you want to match
foreignfield: the field in the other collection that should match with localfield
as: where the combine data should be store. 

$match: is used to filter documents based on specific conditions.
it is same as WHERE in SQL.

$addFields: is used to add new fields to the documents or modify existing ones, it is used to create additional fields 
/*/refer to the contoller file/*/